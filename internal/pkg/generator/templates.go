package generator

// Entity template
const entityTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package entities

import (
	"fmt"
	"time"
	"{{.PackageName}}/internal/pkg/modules"
)

// {{.EntityName}} represents the {{.EntityLower}} entity
type {{.EntityName}} struct {
	ID        uint   ` + "`json:\"id\" db:\"id\"`" + `
{{- if .Timestamps}}
	CreatedAt int64  ` + "`json:\"created_at\" db:\"created_at\"`" + `
	UpdatedAt int64  ` + "`json:\"updated_at\" db:\"updated_at\"`" + `
{{- end}}
{{- if .SoftDelete}}
	DeletedAt *int64 ` + "`json:\"deleted_at,omitempty\" db:\"deleted_at\"`" + `
{{- end}}

	// Add your custom fields here
	Name        string ` + "`json:\"name\" db:\"name\" validate:\"required\"`" + `
	Description string ` + "`json:\"description\" db:\"description\"`" + `
}

// GetID returns the entity ID
func (e *{{.EntityName}}) GetID() uint {
	return e.ID
}

// SetID sets the entity ID
func (e *{{.EntityName}}) SetID(id uint) {
	e.ID = id
}

// GetTableName returns the database table name
func (e *{{.EntityName}}) GetTableName() string {
	return "{{.TableName}}"
}

// Validate validates the entity
func (e *{{.EntityName}}) Validate() error {
	if e.Name == "" {
		return fmt.Errorf("name is required")
	}
	return nil
}

{{- if .Timestamps}}

// GetCreatedAt returns the created timestamp
func (e *{{.EntityName}}) GetCreatedAt() int64 {
	return e.CreatedAt
}

// SetCreatedAt sets the created timestamp
func (e *{{.EntityName}}) SetCreatedAt(timestamp int64) {
	e.CreatedAt = timestamp
}

// GetUpdatedAt returns the updated timestamp
func (e *{{.EntityName}}) GetUpdatedAt() int64 {
	return e.UpdatedAt
}

// SetUpdatedAt sets the updated timestamp
func (e *{{.EntityName}}) SetUpdatedAt(timestamp int64) {
	e.UpdatedAt = timestamp
}
{{- end}}

{{- if .SoftDelete}}

// IsDeleted returns whether the entity is soft deleted
func (e *{{.EntityName}}) IsDeleted() bool {
	return e.DeletedAt != nil
}

// SetDeleted sets the soft delete status
func (e *{{.EntityName}}) SetDeleted(deleted bool) {
	if deleted {
		now := time.Now().Unix()
		e.DeletedAt = &now
	} else {
		e.DeletedAt = nil
	}
}

// GetDeletedAt returns the deleted timestamp
func (e *{{.EntityName}}) GetDeletedAt() *int64 {
	return e.DeletedAt
}

// SetDeletedAt sets the deleted timestamp
func (e *{{.EntityName}}) SetDeletedAt(timestamp *int64) {
	e.DeletedAt = timestamp
}
{{- end}}

// Compile-time interface checks
var (
	_ modules.Entity = (*{{.EntityName}})(nil)
{{- if .Timestamps}}
	_ modules.Timestampable = (*{{.EntityName}})(nil)
{{- end}}
{{- if .SoftDelete}}
	_ modules.SoftDeletable = (*{{.EntityName}})(nil)
{{- end}}
)
`

// Repository interface template
const repositoryInterfaceTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package repositories

import (
	"context"
	"{{.PackageName}}/internal/domain/entities"
	"{{.PackageName}}/internal/pkg/modules"
)

// {{.EntityName}}Repository defines the interface for {{.EntityLower}} repository
type {{.EntityName}}Repository interface {
	modules.Repository[entities.{{.EntityName}}]

	// Add custom repository methods here
	FindByName(ctx context.Context, name string) (*entities.{{.EntityName}}, error)
	FindByNameLike(ctx context.Context, pattern string) ([]*entities.{{.EntityName}}, error)
}
`

// Repository implementation template
const repositoryImplTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package repositories

import (
	"context"
	"database/sql"
	"fmt"

	"{{.PackageName}}/internal/domain/entities"
	"{{.PackageName}}/internal/pkg/crud"
	"{{.PackageName}}/internal/pkg/modules"
)

// {{.EntityLower}}Repository implements {{.EntityName}}Repository interface
type {{.EntityLower}}Repository struct {
	*crud.GenericRepository[entities.{{.EntityName}}]
}

// New{{.EntityName}}Repository creates a new {{.EntityLower}} repository
func New{{.EntityName}}Repository(db *sql.DB) {{.EntityName}}Repository {
	entity := &entities.{{.EntityName}}{}
	return &{{.EntityLower}}Repository{
		GenericRepository: crud.NewGenericRepository(db, entity),
	}
}

// FindByName finds a {{.EntityLower}} by name
func (r *{{.EntityLower}}Repository) FindByName(ctx context.Context, name string) (*entities.{{.EntityName}}, error) {
	query := ` + "`SELECT * FROM {{.TableName}} WHERE name = $1`" + `
{{- if .SoftDelete}}
	query += ` + "` AND deleted_at IS NULL`" + `
{{- end}}

	var entity entities.{{.EntityName}}
	err := r.DB.QueryRowContext(ctx, query, name).Scan(
		&entity.ID,
{{- if .Timestamps}}
		&entity.CreatedAt,
		&entity.UpdatedAt,
{{- end}}
{{- if .SoftDelete}}
		&entity.DeletedAt,
{{- end}}
		&entity.Name,
		&entity.Description,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("{{.EntityLower}} with name '%s' not found", name)
		}
		return nil, fmt.Errorf("failed to find {{.EntityLower}} by name: %w", err)
	}

	return &entity, nil
}

// FindByNameLike finds {{.EntityLower}}s with names matching pattern
func (r *{{.EntityLower}}Repository) FindByNameLike(ctx context.Context, pattern string) ([]*entities.{{.EntityName}}, error) {
	query := ` + "`SELECT * FROM {{.TableName}} WHERE name ILIKE $1`" + `
{{- if .SoftDelete}}
	query += ` + "` AND deleted_at IS NULL`" + `
{{- end}}

	rows, err := r.DB.QueryContext(ctx, query, "%"+pattern+"%")
	if err != nil {
		return nil, fmt.Errorf("failed to query {{.EntityLower}}s by name pattern: %w", err)
	}
	defer rows.Close()

	var entities []*entities.{{.EntityName}}
	for rows.Next() {
		var entity entities.{{.EntityName}}
		err := rows.Scan(
			&entity.ID,
{{- if .Timestamps}}
			&entity.CreatedAt,
			&entity.UpdatedAt,
{{- end}}
{{- if .SoftDelete}}
			&entity.DeletedAt,
{{- end}}
			&entity.Name,
			&entity.Description,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan {{.EntityLower}}: %w", err)
		}
		entities = append(entities, &entity)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("row iteration error: %w", err)
	}

	return entities, nil
}
`

// Service interface template
const serviceInterfaceTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package services

import (
	"context"
	"{{.PackageName}}/internal/domain/entities"
	"{{.PackageName}}/internal/pkg/modules"
)

// {{.EntityName}}Service defines the interface for {{.EntityLower}} service
type {{.EntityName}}Service interface {
	modules.Service[entities.{{.EntityName}}]

	// Add custom service methods here
	FindByName(ctx context.Context, name string) (*entities.{{.EntityName}}, error)
	SearchByName(ctx context.Context, pattern string) ([]*entities.{{.EntityName}}, error)
	ValidateName(ctx context.Context, name string) error
}
`

// Service implementation template
const serviceImplTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package services

import (
	"context"
	"fmt"
	"strings"

	"{{.PackageName}}/internal/database/repositories"
	"{{.PackageName}}/internal/domain/entities"
	"{{.PackageName}}/internal/pkg/crud"
	"{{.PackageName}}/internal/pkg/logger"
	"{{.PackageName}}/internal/pkg/modules"
)

// {{.EntityLower}}Service implements {{.EntityName}}Service interface
type {{.EntityLower}}Service struct {
	*crud.GenericService[entities.{{.EntityName}}]
	repository repositories.{{.EntityName}}Repository
	logger     *logger.Logger
}

// New{{.EntityName}}Service creates a new {{.EntityLower}} service
func New{{.EntityName}}Service(repository repositories.{{.EntityName}}Repository, logger *logger.Logger) {{.EntityName}}Service {
	genericService := crud.NewGenericService[entities.{{.EntityName}}](repository)

	return &{{.EntityLower}}Service{
		GenericService: genericService,
		repository:     repository,
		logger:         logger,
	}
}

// FindByName finds a {{.EntityLower}} by name
func (s *{{.EntityLower}}Service) FindByName(ctx context.Context, name string) (*entities.{{.EntityName}}, error) {
	if err := s.ValidateName(ctx, name); err != nil {
		return nil, err
	}

	return s.repository.FindByName(ctx, name)
}

// SearchByName searches {{.EntityLower}}s by name pattern
func (s *{{.EntityLower}}Service) SearchByName(ctx context.Context, pattern string) ([]*entities.{{.EntityName}}, error) {
	if strings.TrimSpace(pattern) == "" {
		return nil, fmt.Errorf("search pattern cannot be empty")
	}

	return s.repository.FindByNameLike(ctx, pattern)
}

// ValidateName validates a {{.EntityLower}} name
func (s *{{.EntityLower}}Service) ValidateName(ctx context.Context, name string) error {
	name = strings.TrimSpace(name)

	if name == "" {
		return fmt.Errorf("name cannot be empty")
	}

	if len(name) < 2 {
		return fmt.Errorf("name must be at least 2 characters long")
	}

	if len(name) > 100 {
		return fmt.Errorf("name cannot exceed 100 characters")
	}

	return nil
}

// Business rule validation override
func (s *{{.EntityLower}}Service) validateBusinessRules(ctx context.Context, entity *entities.{{.EntityName}}, operation string) error {
	// Validate name
	if err := s.ValidateName(ctx, entity.Name); err != nil {
		return err
	}

	// Check for duplicate names (except for updates of the same entity)
	if operation == "create" || operation == "update" {
		existing, err := s.repository.FindByName(ctx, entity.Name)
		if err == nil && existing != nil && existing.ID != entity.ID {
			return fmt.Errorf("{{.EntityLower}} with name '%s' already exists", entity.Name)
		}
	}

	return nil
}
`

// Handler template
const handlerTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package handlers

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"

	"{{.PackageName}}/internal/domain/services"
	"{{.PackageName}}/internal/pkg/crud"
	"{{.PackageName}}/internal/pkg/logger"
)

// {{.EntityName}}Handler handles HTTP requests for {{.EntityLower}}s
type {{.EntityName}}Handler struct {
	*crud.GenericHandler[entities.{{.EntityName}}]
	service services.{{.EntityName}}Service
	logger  *logger.Logger
}

// New{{.EntityName}}Handler creates a new {{.EntityLower}} handler
func New{{.EntityName}}Handler(service services.{{.EntityName}}Service, logger *logger.Logger) *{{.EntityName}}Handler {
	genericHandler := crud.NewGenericHandler(service, logger, "{{.EntityLower}}")

	return &{{.EntityName}}Handler{
		GenericHandler: genericHandler,
		service:        service,
		logger:         logger,
	}
}

// FindByName handles GET requests to find {{.EntityLower}} by name
// @Summary Find {{.EntityLower}} by name
// @Description Retrieve a {{.EntityLower}} by its name
// @Tags {{.EntityLower}}s
// @Produce json
// @Param name path string true "{{.EntityName}} name"
// @Success 200 {object} object "{{.EntityName}} data"
// @Failure 400 {object} ErrorResponse "Bad request"
// @Failure 404 {object} ErrorResponse "{{.EntityName}} not found"
// @Failure 500 {object} ErrorResponse "Internal server error"
// @Router /{{.EntityLower}}s/name/{name} [get]
func (h *{{.EntityName}}Handler) FindByName(c *gin.Context) {
	name := c.Param("name")
	if name == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid name parameter",
			"message": "Name parameter is required",
		})
		return
	}

	entity, err := h.service.FindByName(c.Request.Context(), name)
	if err != nil {
		h.logger.Error("Failed to find {{.EntityLower}} by name", "error", err, "name", name)
		c.JSON(http.StatusNotFound, gin.H{
			"error":   "{{.EntityName}} not found",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "{{.EntityName}} found successfully",
		"data":    entity,
	})
}

// SearchByName handles GET requests to search {{.EntityLower}}s by name pattern
// @Summary Search {{.EntityLower}}s by name
// @Description Search {{.EntityLower}}s by name pattern
// @Tags {{.EntityLower}}s
// @Produce json
// @Param q query string true "Search pattern"
// @Success 200 {object} object "{{.EntityName}}s data"
// @Failure 400 {object} ErrorResponse "Bad request"
// @Failure 500 {object} ErrorResponse "Internal server error"
// @Router /{{.EntityLower}}s/search [get]
func (h *{{.EntityName}}Handler) SearchByName(c *gin.Context) {
	pattern := c.Query("q")
	if pattern == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid search parameter",
			"message": "Search query 'q' is required",
		})
		return
	}

	entities, err := h.service.SearchByName(c.Request.Context(), pattern)
	if err != nil {
		h.logger.Error("Failed to search {{.EntityLower}}s", "error", err, "pattern", pattern)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to search {{.EntityLower}}s",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "{{.EntityName}}s found successfully",
		"data":    entities,
		"count":   len(entities),
	})
}
`

// Module template
const moduleTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package modules

import (
	"context"
	"database/sql"

	"github.com/gin-gonic/gin"

	"{{.PackageName}}/internal/api/handlers"
	"{{.PackageName}}/internal/database/repositories"
	"{{.PackageName}}/internal/domain/services"
	"{{.PackageName}}/internal/pkg/container"
	"{{.PackageName}}/internal/pkg/modules"
)

// {{.EntityName}}Module implements the Module interface for {{.EntityLower}} functionality
type {{.EntityName}}Module struct {
	name         string
	version      string
	dependencies []string
}

// New{{.EntityName}}Module creates a new {{.EntityLower}} module
func New{{.EntityName}}Module() modules.Module {
	return &{{.EntityName}}Module{
		name:         "{{.EntityLower}}",
		version:      "1.0.0",
		dependencies: []string{}, // Add module dependencies here
	}
}

// Name returns the module name
func (m *{{.EntityName}}Module) Name() string {
	return m.name
}

// Version returns the module version
func (m *{{.EntityName}}Module) Version() string {
	return m.version
}

// Dependencies returns the module dependencies
func (m *{{.EntityName}}Module) Dependencies() []string {
	return m.dependencies
}

// RegisterServices registers module services with the container
func (m *{{.EntityName}}Module) RegisterServices(container *container.Container) error {
	// Register repository
	container.RegisterSingleton("{{.EntityLower}}Repository", func(c *container.Container) interface{} {
		db := c.MustGet("db").(*sql.DB)
		return repositories.New{{.EntityName}}Repository(db)
	})

	// Register service
	container.RegisterSingleton("{{.EntityLower}}Service", func(c *container.Container) interface{} {
		repo := c.MustGet("{{.EntityLower}}Repository").(repositories.{{.EntityName}}Repository)
		logger := c.MustGet("logger").(*logger.Logger)
		return services.New{{.EntityName}}Service(repo, logger)
	})

	// Register handler
	container.RegisterSingleton("{{.EntityLower}}Handler", func(c *container.Container) interface{} {
		service := c.MustGet("{{.EntityLower}}Service").(services.{{.EntityName}}Service)
		logger := c.MustGet("logger").(*logger.Logger)
		return handlers.New{{.EntityName}}Handler(service, logger)
	})

	return nil
}

// RegisterRoutes registers module routes
func (m *{{.EntityName}}Module) RegisterRoutes(router *gin.RouterGroup, deps *modules.Dependencies) error {
	handler := deps.Container.MustGet("{{.EntityLower}}Handler").(*handlers.{{.EntityName}}Handler)

	{{.EntityLower}}Group := router.Group("/{{.EntityLower}}s")
	{
		{{.EntityLower}}Group.POST("", handler.Create)
		{{.EntityLower}}Group.GET("", handler.List)
		{{.EntityLower}}Group.GET("/:id", handler.GetByID)
		{{.EntityLower}}Group.PUT("/:id", handler.Update)
		{{.EntityLower}}Group.DELETE("/:id", handler.Delete)

		// Custom routes
		{{.EntityLower}}Group.GET("/name/:name", handler.FindByName)
		{{.EntityLower}}Group.GET("/search", handler.SearchByName)

		// Additional routes
		{{.EntityLower}}Group.POST("/bulk", handler.BulkCreate)
		{{.EntityLower}}Group.GET("/count", handler.Count)
	}

	return nil
}

// Migrate runs database migrations for the module
func (m *{{.EntityName}}Module) Migrate(db *sql.DB) error {
	// Create {{.TableName}} table
	query := ` + "`CREATE TABLE IF NOT EXISTS {{.TableName}} (" + `
		` + "`id SERIAL PRIMARY KEY," + `
{{- if .Timestamps}}
		` + "`created_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM NOW())," + `
		` + "`updated_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM NOW())," + `
{{- end}}
{{- if .SoftDelete}}
		` + "`deleted_at BIGINT," + `
{{- end}}
		` + "`name VARCHAR(100) NOT NULL UNIQUE," + `
		` + "`description TEXT" + `
	` + "`)`" + `

	_, err := db.Exec(query)
	return err
}

// Initialize initializes the module
func (m *{{.EntityName}}Module) Initialize(ctx context.Context) error {
	// Add module initialization logic here
	return nil
}

// Shutdown gracefully shuts down the module
func (m *{{.EntityName}}Module) Shutdown(ctx context.Context) error {
	// Add module cleanup logic here
	return nil
}
`

// Test templates
const entityTestTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package entities

import (
	"testing"
	"github.com/stretchr/testify/assert"
)

func Test{{.EntityName}}_GetID(t *testing.T) {
	entity := &{{.EntityName}}{ID: 1}
	assert.Equal(t, uint(1), entity.GetID())
}

func Test{{.EntityName}}_SetID(t *testing.T) {
	entity := &{{.EntityName}}{}
	entity.SetID(1)
	assert.Equal(t, uint(1), entity.ID)
}

func Test{{.EntityName}}_GetTableName(t *testing.T) {
	entity := &{{.EntityName}}{}
	assert.Equal(t, "{{.TableName}}", entity.GetTableName())
}

func Test{{.EntityName}}_Validate(t *testing.T) {
	tests := []struct {
		name    string
		entity  {{.EntityName}}
		wantErr bool
	}{
		{
			name:    "valid entity",
			entity:  {{.EntityName}}{Name: "Test {{.EntityName}}"},
			wantErr: false,
		},
		{
			name:    "invalid entity - empty name",
			entity:  {{.EntityName}}{Name: ""},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.entity.Validate()
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}
`

const repositoryTestTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package repositories

import (
	"context"
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// Add your repository tests here
func Test{{.EntityName}}Repository_FindByName(t *testing.T) {
	// TODO: Implement repository tests
	t.Skip("Repository tests not yet implemented")
}
`

const serviceTestTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package services

import (
	"context"
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// Add your service tests here
func Test{{.EntityName}}Service_FindByName(t *testing.T) {
	// TODO: Implement service tests
	t.Skip("Service tests not yet implemented")
}
`

const handlerTestTemplate = `// Code generated by {{.Generator}} at {{.GeneratedAt}}. DO NOT EDIT.

package handlers

import (
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/gin-gonic/gin"
)

// Add your handler tests here
func Test{{.EntityName}}Handler_FindByName(t *testing.T) {
	// TODO: Implement handler tests
	t.Skip("Handler tests not yet implemented")
}
`