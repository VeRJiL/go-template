package registry

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"sync"

	"github.com/gin-gonic/gin"

	"github.com/VeRJiL/go-template/internal/pkg/container"
	"github.com/VeRJiL/go-template/internal/pkg/crud"
	"github.com/VeRJiL/go-template/internal/pkg/logger"
	"github.com/VeRJiL/go-template/internal/pkg/modules"
)

// EntityRegistration holds information about a registered entity
type EntityRegistration struct {
	Name           string
	EntityType     reflect.Type
	Repository     interface{}
	Service        interface{}
	Handler        interface{}
	Config         modules.EntityConfig
	AutoGenerated  bool
	RoutePrefix    string
	Middleware     []gin.HandlerFunc
	Permissions    map[string][]string
}

// EntityRegistry manages entity registration and auto-generation
type EntityRegistry struct {
	entities  map[string]*EntityRegistration
	mu        sync.RWMutex
	logger    *logger.Logger
	container *container.Container
	db        *sql.DB
}

// NewEntityRegistry creates a new entity registry
func NewEntityRegistry(logger *logger.Logger, container *container.Container, db *sql.DB) *EntityRegistry {
	return &EntityRegistry{
		entities:  make(map[string]*EntityRegistration),
		logger:    logger,
		container: container,
		db:        db,
	}
}

// RegisterEntity registers an entity with full auto-generation
func (r *EntityRegistry) RegisterEntity(entityType reflect.Type, config modules.EntityConfig) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	name := config.Name
	if name == "" {
		name = entityType.Name()
	}

	if _, exists := r.entities[name]; exists {
		return fmt.Errorf("entity %s is already registered", name)
	}

	// Create a zero value instance for the entity
	entityPtr := reflect.New(entityType)
	entity := entityPtr.Interface()

	// Validate that entity implements Entity interface
	if _, ok := entity.(modules.Entity); !ok {
		return fmt.Errorf("type %s does not implement Entity interface", entityType.Name())
	}

	registration := &EntityRegistration{
		Name:         name,
		EntityType:   entityType,
		Config:       config,
		AutoGenerated: true,
		RoutePrefix:  "/" + config.TableName,
	}

	// Auto-generate repository
	if err := r.generateRepository(registration, entity); err != nil {
		return fmt.Errorf("failed to generate repository for %s: %w", name, err)
	}

	// Auto-generate service
	if err := r.generateService(registration); err != nil {
		return fmt.Errorf("failed to generate service for %s: %w", name, err)
	}

	// Auto-generate handler
	if err := r.generateHandler(registration); err != nil {
		return fmt.Errorf("failed to generate handler for %s: %w", name, err)
	}

	r.entities[name] = registration
	r.logger.Info("Entity registered with auto-generation", "entity", name, "table", config.TableName)

	return nil
}

// RegisterManualEntity registers an entity with manually provided implementations
func (r *EntityRegistry) RegisterManualEntity(name string, entityType reflect.Type, repository, service, handler interface{}) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.entities[name]; exists {
		return fmt.Errorf("entity %s is already registered", name)
	}

	registration := &EntityRegistration{
		Name:         name,
		EntityType:   entityType,
		Repository:   repository,
		Service:      service,
		Handler:      handler,
		AutoGenerated: false,
		RoutePrefix:  "/" + name,
	}

	r.entities[name] = registration
	r.logger.Info("Entity registered manually", "entity", name)

	return nil
}

// GetEntity retrieves an entity registration by name
func (r *EntityRegistry) GetEntity(name string) (*EntityRegistration, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	entity, exists := r.entities[name]
	if !exists {
		return nil, fmt.Errorf("entity %s not found", name)
	}

	return entity, nil
}

// GetEntities returns all registered entities
func (r *EntityRegistry) GetEntities() map[string]*EntityRegistration {
	r.mu.RLock()
	defer r.mu.RUnlock()

	entities := make(map[string]*EntityRegistration)
	for name, entity := range r.entities {
		entities[name] = entity
	}

	return entities
}

// RegisterRoutes registers all entity routes with the router
func (r *EntityRegistry) RegisterRoutes(router *gin.RouterGroup) error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	for name, registration := range r.entities {
		if err := r.registerEntityRoutes(router, registration); err != nil {
			return fmt.Errorf("failed to register routes for entity %s: %w", name, err)
		}
	}

	return nil
}

// Helper methods for auto-generation

func (r *EntityRegistry) generateRepository(registration *EntityRegistration, entity interface{}) error {
	// Create repository instance
	repo := crud.NewGenericRepository(r.db, entity.(modules.Entity))

	// Register in container
	repoName := fmt.Sprintf("%sRepository", registration.Name)
	r.container.Register(repoName, repo)

	registration.Repository = repo
	r.logger.Debug("Generated repository", "entity", registration.Name, "repository", repoName)

	return nil
}

func (r *EntityRegistry) generateService(registration *EntityRegistration) error {
	// Get repository from registration
	repo, ok := registration.Repository.(modules.Repository[modules.Entity])
	if !ok {
		return fmt.Errorf("invalid repository type for entity %s", registration.Name)
	}

	// Create generic service
	service := crud.NewGenericService(repo)

	// Register in container
	serviceName := fmt.Sprintf("%sService", registration.Name)
	r.container.Register(serviceName, service)

	registration.Service = service
	r.logger.Debug("Generated service", "entity", registration.Name, "service", serviceName)

	return nil
}

func (r *EntityRegistry) generateHandler(registration *EntityRegistration) error {
	// Get service from registration
	service, ok := registration.Service.(modules.Service[modules.Entity])
	if !ok {
		return fmt.Errorf("invalid service type for entity %s", registration.Name)
	}

	// Create generic handler
	handler := crud.NewGenericHandler(service, r.logger, registration.Name)

	// Register in container
	handlerName := fmt.Sprintf("%sHandler", registration.Name)
	r.container.Register(handlerName, handler)

	registration.Handler = handler
	r.logger.Debug("Generated handler", "entity", registration.Name, "handler", handlerName)

	return nil
}

func (r *EntityRegistry) registerEntityRoutes(router *gin.RouterGroup, registration *EntityRegistration) error {
	handler, ok := registration.Handler.(*crud.GenericHandler[modules.Entity])
	if !ok {
		return fmt.Errorf("invalid handler type for entity %s", registration.Name)
	}

	// Create entity group
	entityGroup := router.Group(registration.RoutePrefix)

	// Apply middleware if configured
	for _, middleware := range registration.Middleware {
		entityGroup.Use(middleware)
	}

	// Register CRUD routes
	entityGroup.POST("", handler.Create)
	entityGroup.GET("", handler.List)
	entityGroup.GET("/:id", handler.GetByID)
	entityGroup.PUT("/:id", handler.Update)
	entityGroup.DELETE("/:id", handler.Delete)

	// Register additional routes if handler supports them
	if bulkHandler, ok := interface{}(handler).(interface{ BulkCreate(*gin.Context) }); ok {
		entityGroup.POST("/bulk", bulkHandler.BulkCreate)
	}

	if countHandler, ok := interface{}(handler).(interface{ Count(*gin.Context) }); ok {
		entityGroup.GET("/count", countHandler.Count)
	}

	r.logger.Info("Registered entity routes",
		"entity", registration.Name,
		"prefix", registration.RoutePrefix,
		"routes", []string{"POST", "GET", "GET/:id", "PUT/:id", "DELETE/:id"})

	return nil
}

// Migrate runs database migrations for all registered entities
func (r *EntityRegistry) Migrate(ctx context.Context) error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	r.logger.Info("Running entity migrations", "count", len(r.entities))

	for name, registration := range r.entities {
		if registration.Config.TableName == "" {
			continue
		}

		// Basic table creation (in a real implementation, you'd want proper migration files)
		if err := r.createTableIfNotExists(registration); err != nil {
			return fmt.Errorf("failed to create table for entity %s: %w", name, err)
		}
	}

	return nil
}

func (r *EntityRegistry) createTableIfNotExists(registration *EntityRegistration) error {
	tableName := registration.Config.TableName

	// Check if table exists
	var exists bool
	query := `SELECT EXISTS (
		SELECT FROM information_schema.tables
		WHERE table_schema = 'public'
		AND table_name = $1
	)`

	err := r.db.QueryRow(query, tableName).Scan(&exists)
	if err != nil {
		return fmt.Errorf("failed to check table existence: %w", err)
	}

	if exists {
		r.logger.Debug("Table already exists", "table", tableName)
		return nil
	}

	// Generate basic CREATE TABLE statement
	createSQL := r.generateCreateTableSQL(registration)

	_, err = r.db.Exec(createSQL)
	if err != nil {
		return fmt.Errorf("failed to create table %s: %w", tableName, err)
	}

	r.logger.Info("Created table", "table", tableName)
	return nil
}

func (r *EntityRegistry) generateCreateTableSQL(registration *EntityRegistration) string {
	tableName := registration.Config.TableName

	// Basic table structure - in a real implementation,
	// you'd analyze the entity struct fields
	sql := fmt.Sprintf(`
		CREATE TABLE IF NOT EXISTS %s (
			id SERIAL PRIMARY KEY,
			created_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM NOW()),
			updated_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM NOW())
	`, tableName)

	// Add soft delete column if enabled
	if registration.Config.SoftDelete {
		sql += ",\n\t\t\tdeleted_at BIGINT"
	}

	sql += "\n\t\t)"

	return sql
}

// GetEntityNames returns all registered entity names
func (r *EntityRegistry) GetEntityNames() []string {
	r.mu.RLock()
	defer r.mu.RUnlock()

	names := make([]string, 0, len(r.entities))
	for name := range r.entities {
		names = append(names, name)
	}

	return names
}

// HasEntity checks if an entity is registered
func (r *EntityRegistry) HasEntity(name string) bool {
	r.mu.RLock()
	defer r.mu.RUnlock()

	_, exists := r.entities[name]
	return exists
}

// GetEntityCount returns the number of registered entities
func (r *EntityRegistry) GetEntityCount() int {
	r.mu.RLock()
	defer r.mu.RUnlock()

	return len(r.entities)
}