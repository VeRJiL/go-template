package services

import (
	"context"
	"fmt"
	"time"

	"github.com/yourname/go-template/internal/domain/entities"
	"github.com/yourname/go-template/internal/pkg/messagebroker"
	"github.com/yourname/go-template/internal/pkg/messagebroker/events"
	"github.com/yourname/go-template/internal/pkg/messagebroker/jobs"
)

// UserMessagingService provides async messaging functionality for user operations
type UserMessagingService struct {
	eventPublisher *events.UserEventPublisher
	jobEnqueuer    *jobs.UserJobEnqueuer
	messageBroker  *messagebroker.Manager
}

// NewUserMessagingService creates a new user messaging service
func NewUserMessagingService(messageBroker *messagebroker.Manager) *UserMessagingService {
	return &UserMessagingService{
		eventPublisher: events.NewUserEventPublisher(messageBroker),
		jobEnqueuer:    jobs.NewUserJobEnqueuer(messageBroker),
		messageBroker:  messageBroker,
	}
}

// HandleUserCreated handles async operations when a user is created
func (s *UserMessagingService) HandleUserCreated(ctx context.Context, user *entities.User, ipAddress, userAgent string) error {
	// Publish user created event
	eventData := events.UserCreatedData{
		UserEventData: events.UserEventData{
			UserID:    user.ID,
			Email:     user.Email,
			Username:  user.Username,
			Timestamp: time.Now(),
			IPAddress: ipAddress,
			UserAgent: userAgent,
		},
		IsEmailVerified: user.IsEmailVerified,
		Role:           "user", // Default role
	}

	if err := s.eventPublisher.PublishUserCreated(ctx, eventData); err != nil {
		return fmt.Errorf("failed to publish user created event: %w", err)
	}

	// Enqueue welcome email job
	welcomeEmailData := jobs.WelcomeEmailJobData{
		EmailJobData: jobs.EmailJobData{
			UserID:     user.ID,
			Email:      user.Email,
			TemplateID: "welcome_email",
			Subject:    "Welcome to Our Platform!",
			Variables: map[string]interface{}{
				"username": user.Username,
				"email":    user.Email,
			},
			Priority: 7, // High priority
		},
		Username: user.Username,
	}

	if err := s.jobEnqueuer.EnqueueWelcomeEmail(ctx, welcomeEmailData); err != nil {
		return fmt.Errorf("failed to enqueue welcome email: %w", err)
	}

	// Enqueue email verification if needed
	if !user.IsEmailVerified {
		verificationData := jobs.EmailJobData{
			UserID:     user.ID,
			Email:      user.Email,
			TemplateID: "email_verification",
			Subject:    "Please verify your email address",
			Variables: map[string]interface{}{
				"username":         user.Username,
				"verification_url": fmt.Sprintf("https://yourapp.com/verify?token=%s", "generated-token"),
			},
			Priority: 8, // High priority
		}

		if err := s.jobEnqueuer.EnqueueEmailVerification(ctx, verificationData); err != nil {
			return fmt.Errorf("failed to enqueue email verification: %w", err)
		}
	}

	return nil
}

// HandleUserUpdated handles async operations when a user is updated
func (s *UserMessagingService) HandleUserUpdated(ctx context.Context, user *entities.User, changedFields []string, oldValues map[string]interface{}, ipAddress, userAgent string) error {
	// Publish user updated event
	eventData := events.UserUpdatedData{
		UserEventData: events.UserEventData{
			UserID:    user.ID,
			Email:     user.Email,
			Username:  user.Username,
			Timestamp: time.Now(),
			IPAddress: ipAddress,
			UserAgent: userAgent,
		},
		ChangedFields: changedFields,
		OldValues:     oldValues,
	}

	if err := s.eventPublisher.PublishUserUpdated(ctx, eventData); err != nil {
		return fmt.Errorf("failed to publish user updated event: %w", err)
	}

	// If email was changed, send verification email
	for _, field := range changedFields {
		if field == "email" {
			verificationData := jobs.EmailJobData{
				UserID:     user.ID,
				Email:      user.Email,
				TemplateID: "email_verification",
				Subject:    "Please verify your new email address",
				Variables: map[string]interface{}{
					"username":         user.Username,
					"verification_url": fmt.Sprintf("https://yourapp.com/verify?token=%s", "generated-token"),
				},
				Priority: 8, // High priority
			}

			if err := s.jobEnqueuer.EnqueueEmailVerification(ctx, verificationData); err != nil {
				return fmt.Errorf("failed to enqueue email verification for updated email: %w", err)
			}
			break
		}
	}

	return nil
}

// HandleUserDeleted handles async operations when a user is deleted
func (s *UserMessagingService) HandleUserDeleted(ctx context.Context, user *entities.User, deletedBy uint, reason string, ipAddress, userAgent string) error {
	// Publish user deleted event
	eventData := events.UserDeletedData{
		UserEventData: events.UserEventData{
			UserID:    user.ID,
			Email:     user.Email,
			Username:  user.Username,
			Timestamp: time.Now(),
			IPAddress: ipAddress,
			UserAgent: userAgent,
		},
		DeletedBy: deletedBy,
		Reason:    reason,
	}

	if err := s.eventPublisher.PublishUserDeleted(ctx, eventData); err != nil {
		return fmt.Errorf("failed to publish user deleted event: %w", err)
	}

	// Enqueue data cleanup job (delayed by 30 days)
	cleanupData := jobs.UserDataCleanupJobData{
		UserID:     user.ID,
		DeletedAt:  time.Now(),
		RetainDays: 30,
		DataTypes:  []string{"profiles", "posts", "comments", "files", "analytics"},
	}

	if err := s.jobEnqueuer.EnqueueUserDataCleanup(ctx, cleanupData, 30*24*time.Hour); err != nil {
		return fmt.Errorf("failed to enqueue user data cleanup: %w", err)
	}

	return nil
}

// HandleUserLogin handles async operations when a user logs in
func (s *UserMessagingService) HandleUserLogin(ctx context.Context, user *entities.User, loginMethod string, success bool, failureReason string, ipAddress, userAgent string) error {
	// Publish user login event
	eventData := events.UserLoginData{
		UserEventData: events.UserEventData{
			UserID:    user.ID,
			Email:     user.Email,
			Username:  user.Username,
			Timestamp: time.Now(),
			IPAddress: ipAddress,
			UserAgent: userAgent,
		},
		LoginMethod:   loginMethod,
		Success:       success,
		FailureReason: failureReason,
	}

	if err := s.eventPublisher.PublishUserLogin(ctx, eventData); err != nil {
		return fmt.Errorf("failed to publish user login event: %w", err)
	}

	// For successful logins, check for suspicious activity
	if success {
		// You could implement location-based alerts, device detection, etc.
		// For now, we'll just send a notification for new device logins
		notificationData := jobs.UserNotificationJobData{
			UserID:   user.ID,
			Type:     "security",
			Title:    "New Login Detected",
			Message:  fmt.Sprintf("New login from %s", ipAddress),
			Data: map[string]interface{}{
				"ip_address": ipAddress,
				"user_agent": userAgent,
				"timestamp":  time.Now().Unix(),
			},
			Channels: []string{"email", "push"},
			Priority: 6, // Medium-high priority
		}

		if err := s.jobEnqueuer.EnqueueUserNotification(ctx, notificationData); err != nil {
			// Log error but don't fail the login process
			fmt.Printf("Failed to enqueue login notification: %v\n", err)
		}
	}

	return nil
}

// HandleUserLogout handles async operations when a user logs out
func (s *UserMessagingService) HandleUserLogout(ctx context.Context, user *entities.User, ipAddress, userAgent string) error {
	// Publish user logout event
	eventData := events.UserEventData{
		UserID:    user.ID,
		Email:     user.Email,
		Username:  user.Username,
		Timestamp: time.Now(),
		IPAddress: ipAddress,
		UserAgent: userAgent,
	}

	if err := s.eventPublisher.PublishUserLogout(ctx, eventData); err != nil {
		return fmt.Errorf("failed to publish user logout event: %w", err)
	}

	return nil
}

// RequestPasswordReset handles async operations for password reset requests
func (s *UserMessagingService) RequestPasswordReset(ctx context.Context, user *entities.User, resetToken string, expiresAt time.Time) error {
	// Enqueue password reset email (high priority)
	resetEmailData := jobs.PasswordResetJobData{
		EmailJobData: jobs.EmailJobData{
			UserID:     user.ID,
			Email:      user.Email,
			TemplateID: "password_reset",
			Subject:    "Password Reset Request",
			Variables: map[string]interface{}{
				"username":  user.Username,
				"reset_url": fmt.Sprintf("https://yourapp.com/reset?token=%s", resetToken),
				"expires":   expiresAt.Format("2006-01-02 15:04:05"),
			},
			Priority: 10, // Highest priority
		},
		ResetToken: resetToken,
		ExpiresAt:  expiresAt,
	}

	if err := s.jobEnqueuer.EnqueuePasswordResetEmail(ctx, resetEmailData); err != nil {
		return fmt.Errorf("failed to enqueue password reset email: %w", err)
	}

	return nil
}

// SendScheduledNotification sends a notification at a specific time
func (s *UserMessagingService) SendScheduledNotification(ctx context.Context, userID uint, title, message string, scheduledAt time.Time, channels []string) error {
	notificationData := jobs.UserNotificationJobData{
		UserID:      userID,
		Type:        "scheduled",
		Title:       title,
		Message:     message,
		Channels:    channels,
		Priority:    5, // Medium priority
		ScheduledAt: &scheduledAt,
	}

	return s.jobEnqueuer.EnqueueUserNotification(ctx, notificationData)
}

// RequestUserDataExport handles user data export requests
func (s *UserMessagingService) RequestUserDataExport(ctx context.Context, userID uint, email string, requestedBy uint, exportType, format string) error {
	exportData := jobs.UserDataExportJobData{
		UserID:      userID,
		Email:       email,
		RequestedBy: requestedBy,
		ExportType:  exportType,
		Format:      format,
		RequestedAt: time.Now(),
	}

	if err := s.jobEnqueuer.EnqueueUserDataExport(ctx, exportData); err != nil {
		return fmt.Errorf("failed to enqueue user data export: %w", err)
	}

	return nil
}

// BroadcastToUsers broadcasts a message to multiple users
func (s *UserMessagingService) BroadcastToUsers(ctx context.Context, userIDs []uint, title, message string, channels []string) error {
	for _, userID := range userIDs {
		notificationData := jobs.UserNotificationJobData{
			UserID:   userID,
			Type:     "broadcast",
			Title:    title,
			Message:  message,
			Channels: channels,
			Priority: 4, // Medium priority
		}

		if err := s.jobEnqueuer.EnqueueUserNotification(ctx, notificationData); err != nil {
			// Log error but continue with other users
			fmt.Printf("Failed to enqueue broadcast notification for user %d: %v\n", userID, err)
		}
	}

	return nil
}

// SendDelayedReminder sends a reminder after a specified delay
func (s *UserMessagingService) SendDelayedReminder(ctx context.Context, userID uint, reminderType, title, message string, delay time.Duration) error {
	scheduledAt := time.Now().Add(delay)

	notificationData := jobs.UserNotificationJobData{
		UserID:      userID,
		Type:        reminderType,
		Title:       title,
		Message:     message,
		Channels:    []string{"email", "push"},
		Priority:    5,
		ScheduledAt: &scheduledAt,
	}

	return s.jobEnqueuer.EnqueueUserNotification(ctx, notificationData)
}

// GetMessageBrokerStats returns message broker statistics
func (s *UserMessagingService) GetMessageBrokerStats(ctx context.Context) (*messagebroker.BrokerStats, error) {
	return s.messageBroker.GetStats()
}

// IsHealthy checks if the message broker is healthy
func (s *UserMessagingService) IsHealthy(ctx context.Context) bool {
	err := s.messageBroker.Ping(ctx)
	return err == nil
}