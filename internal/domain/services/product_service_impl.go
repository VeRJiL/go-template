// Code generated by go-template enterprise generator at 2025-09-21T19:40:10+03:30. DO NOT EDIT.

package services

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/VeRJiL/go-template/internal/database/repositories"
	"github.com/VeRJiL/go-template/internal/domain/entities"
	"github.com/VeRJiL/go-template/internal/pkg/logger"
	"github.com/VeRJiL/go-template/internal/pkg/modules"
)

// productService implements ProductService interface
type productService struct {
	repository repositories.ProductRepository
	logger     *logger.Logger
}

// NewProductService creates a new product service
func NewProductService(repository repositories.ProductRepository, logger *logger.Logger) ProductService {
	return &productService{
		repository: repository,
		logger:     logger,
	}
}

// Create creates a new product
func (s *productService) Create(ctx context.Context, entity *entities.Product) (*entities.Product, error) {
	// Set timestamps
	now := time.Now().Unix()
	entity.CreatedAt = now
	entity.UpdatedAt = now

	// Validate entity
	if err := s.ValidateName(ctx, entity.Name); err != nil {
		return nil, err
	}

	// Check for duplicate names
	existing, err := s.repository.FindByName(ctx, entity.Name)
	if err == nil && existing != nil {
		return nil, fmt.Errorf("product with name '%s' already exists", entity.Name)
	}

	if err := s.repository.Create(ctx, entity); err != nil {
		return nil, err
	}

	return entity, nil
}

// GetByID retrieves a product by ID
func (s *productService) GetByID(ctx context.Context, id uint) (*entities.Product, error) {
	return s.repository.GetByID(ctx, id)
}

// Update updates an existing product
func (s *productService) Update(ctx context.Context, id uint, entity *entities.Product) (*entities.Product, error) {
	// Set ID and updated timestamp
	entity.ID = id
	entity.UpdatedAt = time.Now().Unix()

	// Validate entity
	if err := s.ValidateName(ctx, entity.Name); err != nil {
		return nil, err
	}

	// Check for duplicate names (except for the same entity)
	existing, err := s.repository.FindByName(ctx, entity.Name)
	if err == nil && existing != nil && existing.ID != entity.ID {
		return nil, fmt.Errorf("product with name '%s' already exists", entity.Name)
	}

	if err := s.repository.Update(ctx, entity); err != nil {
		return nil, err
	}

	return entity, nil
}

// Delete soft deletes a product
func (s *productService) Delete(ctx context.Context, id uint) error {
	return s.repository.Delete(ctx, id)
}

// List retrieves products with pagination
func (s *productService) List(ctx context.Context, filters modules.ListFilters) ([]*entities.Product, int64, error) {
	return s.repository.List(ctx, filters)
}

// Exists checks if a product exists
func (s *productService) Exists(ctx context.Context, id uint) (bool, error) {
	return s.repository.Exists(ctx, id)
}

// FindByName finds a product by name
func (s *productService) FindByName(ctx context.Context, name string) (*entities.Product, error) {
	if err := s.ValidateName(ctx, name); err != nil {
		return nil, err
	}

	return s.repository.FindByName(ctx, name)
}

// SearchByName searches products by name pattern
func (s *productService) SearchByName(ctx context.Context, pattern string) ([]*entities.Product, error) {
	if strings.TrimSpace(pattern) == "" {
		return nil, fmt.Errorf("search pattern cannot be empty")
	}

	return s.repository.FindByNameLike(ctx, pattern)
}

// ValidateName validates a product name
func (s *productService) ValidateName(ctx context.Context, name string) error {
	name = strings.TrimSpace(name)

	if name == "" {
		return fmt.Errorf("name cannot be empty")
	}

	if len(name) < 2 {
		return fmt.Errorf("name must be at least 2 characters long")
	}

	if len(name) > 100 {
		return fmt.Errorf("name cannot exceed 100 characters")
	}

	return nil
}